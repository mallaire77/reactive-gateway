// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: reactive-gateway.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "ReactiveGateway.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ReactiveGatewayRoot

@implementation ReactiveGatewayRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ReactiveGatewayRoot_FileDescriptor

static GPBFileDescriptor *ReactiveGatewayRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.yoppworks.rxgateway.api"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Opacity

GPBEnumDescriptor *Opacity_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Transparent\000MildlyOpaque\000ModeratelyOpaqu"
        "e\000MostlyOpaque\000Opaque\000";
    static const int32_t values[] = {
        Opacity_Transparent,
        Opacity_MildlyOpaque,
        Opacity_ModeratelyOpaque,
        Opacity_MostlyOpaque,
        Opacity_Opaque,
    };
    static const char *extraTextFormatInfo = "\005\000\013\000\001\014\000\002\020\000\003\014\000\004\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Opacity)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Opacity_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Opacity_IsValidValue(int32_t value__) {
  switch (value__) {
    case Opacity_Transparent:
    case Opacity_MildlyOpaque:
    case Opacity_ModeratelyOpaque:
    case Opacity_MostlyOpaque:
    case Opacity_Opaque:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PrepareShapes

@implementation PrepareShapes

@dynamic numberOfShapesToPrepare;

typedef struct PrepareShapes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numberOfShapesToPrepare;
} PrepareShapes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numberOfShapesToPrepare",
        .dataTypeSpecific.className = NULL,
        .number = PrepareShapes_FieldNumber_NumberOfShapesToPrepare,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PrepareShapes__storage_, numberOfShapesToPrepare),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PrepareShapes class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PrepareShapes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\027\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShapeServiceResult

@implementation ShapeServiceResult

@dynamic viable;
@dynamic error;

typedef struct ShapeServiceResult__storage_ {
  uint32_t _has_storage_[1];
  NSString *error;
} ShapeServiceResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viable",
        .dataTypeSpecific.className = NULL,
        .number = ShapeServiceResult_FieldNumber_Viable,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = ShapeServiceResult_FieldNumber_Error,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShapeServiceResult__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShapeServiceResult class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShapeServiceResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAShape

@implementation GetAShape

@dynamic index;

typedef struct GetAShape__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
} GetAShape__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = GetAShape_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAShape__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAShape class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAShape__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetSomeShapes

@implementation GetSomeShapes

@dynamic startingIndex;
@dynamic numberOfShapes;

typedef struct GetSomeShapes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t startingIndex;
  uint32_t numberOfShapes;
} GetSomeShapes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startingIndex",
        .dataTypeSpecific.className = NULL,
        .number = GetSomeShapes_FieldNumber_StartingIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetSomeShapes__storage_, startingIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numberOfShapes",
        .dataTypeSpecific.className = NULL,
        .number = GetSomeShapes_FieldNumber_NumberOfShapes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetSomeShapes__storage_, numberOfShapes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSomeShapes class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSomeShapes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\r\000\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Color

@implementation Color

@dynamic red;
@dynamic green;
@dynamic blue;

typedef struct Color__storage_ {
  uint32_t _has_storage_[1];
  int32_t red;
  int32_t green;
  int32_t blue;
} Color__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "red",
        .dataTypeSpecific.className = NULL,
        .number = Color_FieldNumber_Red,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Color__storage_, red),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "green",
        .dataTypeSpecific.className = NULL,
        .number = Color_FieldNumber_Green,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Color__storage_, green),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blue",
        .dataTypeSpecific.className = NULL,
        .number = Color_FieldNumber_Blue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Color__storage_, blue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Color class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Color__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Shape

@implementation Shape

@dynamic numberOfSides;
@dynamic hasEdgeColor, edgeColor;
@dynamic hasFillColor, fillColor;
@dynamic opacity;
@dynamic width;
@dynamic height;
@dynamic rotation;

typedef struct Shape__storage_ {
  uint32_t _has_storage_[1];
  uint32_t numberOfSides;
  Opacity opacity;
  uint32_t width;
  uint32_t height;
  float rotation;
  Color *edgeColor;
  Color *fillColor;
} Shape__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numberOfSides",
        .dataTypeSpecific.className = NULL,
        .number = Shape_FieldNumber_NumberOfSides,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Shape__storage_, numberOfSides),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "edgeColor",
        .dataTypeSpecific.className = GPBStringifySymbol(Color),
        .number = Shape_FieldNumber_EdgeColor,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Shape__storage_, edgeColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fillColor",
        .dataTypeSpecific.className = GPBStringifySymbol(Color),
        .number = Shape_FieldNumber_FillColor,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Shape__storage_, fillColor),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opacity",
        .dataTypeSpecific.enumDescFunc = Opacity_EnumDescriptor,
        .number = Shape_FieldNumber_Opacity,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Shape__storage_, opacity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = Shape_FieldNumber_Width,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Shape__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = Shape_FieldNumber_Height,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Shape__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rotation",
        .dataTypeSpecific.className = NULL,
        .number = Shape_FieldNumber_Rotation,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Shape__storage_, rotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Shape class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Shape__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\r\000\002\t\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Shape_Opacity_RawValue(Shape *message) {
  GPBDescriptor *descriptor = [Shape descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Shape_FieldNumber_Opacity];
  return GPBGetMessageInt32Field(message, field);
}

void SetShape_Opacity_RawValue(Shape *message, int32_t value) {
  GPBDescriptor *descriptor = [Shape descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Shape_FieldNumber_Opacity];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GetSomeTetrisShapes

@implementation GetSomeTetrisShapes

@dynamic startingIndex;
@dynamic numberOfShapes;
@dynamic dropSpotsArray, dropSpotsArray_Count;

typedef struct GetSomeTetrisShapes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t startingIndex;
  uint32_t numberOfShapes;
  GPBUInt32Array *dropSpotsArray;
} GetSomeTetrisShapes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startingIndex",
        .dataTypeSpecific.className = NULL,
        .number = GetSomeTetrisShapes_FieldNumber_StartingIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetSomeTetrisShapes__storage_, startingIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numberOfShapes",
        .dataTypeSpecific.className = NULL,
        .number = GetSomeTetrisShapes_FieldNumber_NumberOfShapes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetSomeTetrisShapes__storage_, numberOfShapes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dropSpotsArray",
        .dataTypeSpecific.className = NULL,
        .number = GetSomeTetrisShapes_FieldNumber_DropSpotsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetSomeTetrisShapes__storage_, dropSpotsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSomeTetrisShapes class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSomeTetrisShapes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\r\000\002\016\000\003\000dropSpots\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TetrisShape

@implementation TetrisShape

@dynamic hasShape, shape;
@dynamic dropSpot;
@dynamic animate;

typedef struct TetrisShape__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dropSpot;
  Shape *shape;
} TetrisShape__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shape",
        .dataTypeSpecific.className = GPBStringifySymbol(Shape),
        .number = TetrisShape_FieldNumber_Shape,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TetrisShape__storage_, shape),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dropSpot",
        .dataTypeSpecific.className = NULL,
        .number = TetrisShape_FieldNumber_DropSpot,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TetrisShape__storage_, dropSpot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "animate",
        .dataTypeSpecific.className = NULL,
        .number = TetrisShape_FieldNumber_Animate,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TetrisShape class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TetrisShape__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReleaseShapes

@implementation ReleaseShapes


typedef struct ReleaseShapes__storage_ {
  uint32_t _has_storage_[1];
} ReleaseShapes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReleaseShapes class]
                                     rootClass:[ReactiveGatewayRoot class]
                                          file:ReactiveGatewayRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ReleaseShapes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
